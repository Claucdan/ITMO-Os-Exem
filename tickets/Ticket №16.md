# Методы планирования без внешнего управления приоритетами (FCFS, RR, SJF), гарантированное планирование. Описание каждого метода, их достоинства и недостатки.

## First Come First Served (FCFS)
#### Описание  
  Процессы выполняются в порядке их поступления в очередь. Первый пришедший процесс получает процессор первым и работает до завершения или до перехода в состояние ожидания.  
#### Достоинства  
- Простота реализации.  
- Справедливость (процессы обслуживаются в порядке поступления).  
#### Недостатки  
- Низкая эффективность при наличии длительных процессов (эффект "конвоя").  
- Большое среднее время ожидания для коротких процессов, если они следуют за длительными.
#### Пример

| Процесс | CPU burst |                                       |
| ------- | --------- | ------------------------------------- |
| p_0     | 13        | 🔄🔄🔄🔄🔄🔄🔄🔄🔄🔄🔄🔄🔄✅           |
| p_1     | 4         | 💤💤💤💤💤💤💤💤💤💤💤💤💤🔄🔄🔄🔄✅   |
| p_2     | 1         | 💤💤💤💤💤💤💤💤💤💤💤💤💤💤💤💤💤🔄✅ |
Суммарное время выполнения - `T = 18` тактов.  
Среднее полное время выполнения `tau_полн = (13 + 17 + 18) / 3 = 16`.  
Среднее время ожидания `tau_ожид = (0 + 13 + 17) / 3 = 10`

| Процесс | CPU burst |                                       |
| ------- | --------- | ------------------------------------- |
| p_2     | 1         | 🔄✅                                   |
| p_1     | 4         | 💤🔄🔄🔄🔄✅                           |
| p_0     | 13        | 💤💤💤💤💤🔄🔄🔄🔄🔄🔄🔄🔄🔄🔄🔄🔄🔄✅ |
Здесь среднее полное время выполнения `tau_полн = (18 + 5 + 1) / 3 = 8`, а ожидания - `tau_ожид = (5 + 1 + 0) / 3 = 2`

Как можно заметить, среднее время выполнения и время ожидания - сократилось. В этом и недостаток метода: эффективность зависит от перестановки процессов в очереди
## Round Robin (RR)
#### Описание  
  Каждому процессу выделяется фиксированный квант времени (например, 10 мс). Если процесс не завершается за этот квант, он прерывается и помещается в конец очереди.  
#### Достоинства  
- Справедливость: все процессы получают равное время процессора.  
- Хорошая производительность для интерактивных систем (быстрый отклик).  
#### Недостатки
- Зависимость от размера кванта: слишком маленький квант увеличивает накладные расходы на переключение контекста, слишком большой — снижает отзывчивость.  
- Не учитывает приоритеты или длительность процессов. 
#### Пример
|Процесс|CPU burst| |
|---|---|---|
|p_0|13|🔄🔄🔄🔄💤💤💤💤🔄🔄🔄🔄🔄🔄🔄🔄🔄✅|
|p_1|4|💤💤💤💤🔄🔄🔄🔄✅|
|p_2|1|💤💤💤💤💤💤💤💤🔄✅|
Среднее полное время `tau_полн = (18 + 8 + 9) / 3 = 11.7`, ожидания - `tau_ожид = (5 + 4 + 8) / 3 = 5.7`
Если развернуть очередь, то среднее полное время и время ожидания не улучшиться по сравнению с тем, что было в FCFS, но при этом время в худшей перестановке процессов значительно улучшилась.

Теперь пусть `k = 1`:

| Процесс | CPU burst |                                     |
| ------- | --------- | ----------------------------------- |
| p_0     | 13        | 🔄💤💤🔄💤🔄💤🔄💤🔄🔄🔄🔄🔄🔄🔄🔄✅ |
| p_1     | 4         | 💤🔄💤💤🔄💤🔄💤🔄✅                 |
| p_2     | 1         | 💤💤🔄✅                             |
Среднее полное время `tau_полн = (18 + 9 + 3) / 3 = 10`, ожидания - `tau_ожид = (5 + 5 + 2) / 3 = 4`. Таким образом, при уменьшении кванта времени время на исполнение и ожидание уменьшается. Однако алгоритм Round Robin требует некоторое время на переключение процессов, поэтому при `k = 1` среднее время исполнения и ожидания достигает локального максимума

Заметим, что при `k = ∞` алгоритм вырождается в FCFS
## Shortest Job First (SJF)
#### Описание  
  Процессы с наименьшим временем выполнения (CPU-burst) получают процессор первыми. Может быть как вытесняющим (проверка на наличие более коротких процессов через кванты времени), так и не вытесняющим.  
#### Достоинства 
- Минимизирует среднее время ожидания и время выполнения.  
- Оптимален для статических систем, где известны длительности процессов.  
#### Недостатки  
- Требует знания или точного прогноза времени выполнения, что сложно в реальных системах.  
- Риск "голодания" длительных процессов.
#### Пример

| Процесс | CPU burst | Время появления процесса |                                           |
| ------- | --------- | ------------------------ | ----------------------------------------- |
| p_0     | 6         | 0                        | 💤💤💤💤💤💤💤🔄🔄🔄🔄🔄🔄✅               |
| p_1     | 2         | 2                        | ◾️◾️🔄🔄✅                                 |
| p_2     | 7         | 6                        | ◾️◾️◾️◾️◾️◾️💤💤💤💤💤💤💤🔄🔄🔄🔄🔄🔄🔄✅ |
| p_3     | 5         | 0                        | 🔄🔄💤💤🔄🔄🔄✅                           |
Shortest Job First - эффективный, но несправедливый алгоритм
## Гарантированное планирование
#### Описание  
  Каждый процесс получает долю процессорного времени, пропорциональную его "весу" (например, 1/n для n процессов). Коэффициент справедливости 
$$ 
R_i = \frac{r_i}{T_i} \cdot N 
$$
   (где r_i  — время исполнения,  T_i  — время сеанса,  N  — число процессов) используется для выбора следующего процесса.

#### Достоинства  
- Справедливость: предотвращает голодание.  
- Гибкость: можно адаптировать под разные сценарии.  
#### Недостатки  
- Высокие накладные расходы на вычисление коэффициентов.  
- Уязвимость к "взлому" (процессы могут искусственно увеличивать T_i ).
#### Принцип
Определим квант времени `k`.
1. Находим процесс с минимальным коэффициентом справедливости (то есть наиболее обделенный процесс)
2. Даем ему `k` тактов исполнится
3. Далее, если его `R_i` все еще наименьшее среди остальных, то даем ему еще `k` тактов и так далее. Иначе ищем новый процесс
Данный алгоритм оказался неустойчивым ко взлому, например, можно создать программу, которая первые несколько часов будет в состоянии сна, а после пробуждения будет получать все процессорное время
