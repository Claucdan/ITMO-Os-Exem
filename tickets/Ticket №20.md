# Взаимодействие процессов. Условия взаимоисключения и прогресса. Понятие критической секции. Голодание процессов.
## Взаимодействие процессов
Взаимодействие процессов может быть **внешним** и **внутренним**:
- **Внешнее взаимодействие** включает обмен управлением или данными между процессами, например, через `pipe` в Linux или сигналы.
- **Внутреннее взаимодействие** возникает при конкуренции за неразделяемые ресурсы (например, принтер или файловую систему), что требует механизмов синхронизации.
## Условия взаимоисключения и прогресса
Для корректного взаимодействия процессов необходимо выполнение следующих условий:
1. **Взаимоисключение (Mutual Exclusion)**:
   - Только один процесс может находиться в критической секции относительно определенного ресурса в любой момент времени.
   - Пример: если процесс использует принтер, другой процесс не может получить к нему доступ до завершения текущей операции.
2. **Прогресс (Progress)**:
   - Если ресурс свободен, то процесс, желающий его использовать, должен получить доступ без задержек.
   - Пример: если принтер свободен, процесс, запросивший его, должен начать печать, а не ждать бесконечно.
3. **Отсутствие голодания (No Starvation)**:
   - Ни один процесс не должен бесконечно ожидать доступа к ресурсу.
   - Пример: низкоприоритетные процессы не должны блокироваться высокоприоритетными навсегда.
4. **Отсутствие тупиков (No Deadlock)**:
   - Не должно возникать ситуаций, когда процессы взаимно блокируют друг друга, ожидая освобождения ресурсов.
## Понятие критической секции
**Критическая секция** — это часть кода процесса, которая обращается к неразделяемому ресурсу. Для обеспечения взаимоисключения процессы должны выполнять следующие действия:
1. **Пролог**: запрос доступа к ресурсу (например, через мьютекс или семафор).
2. **Критическая секция**: выполнение операций с ресурсом.
3. **Эпилог**: освобождение ресурса и уведомление других процессов.

Пример на псевдокоде:
```c
// Пролог: запрос доступа
lock(mutex);
// Критическая секция: работа с ресурсом
// ...
// Эпилог: освобождение ресурса
unlock(mutex);
```
## Голодание процессов
**Голодание** возникает, когда процесс не может получить доступ к ресурсу из-за того, что другие процессы (обычно с более высоким приоритетом) постоянно его опережают. Примеры:
- В алгоритме SJF (Shortest Job First) длинные задачи могут никогда не выполняться, если постоянно появляются короткие.
- В многоуровневых очередях низкоприоритетные процессы могут ждать слишком долго.
**Решение**:
- Использование механизмов "старения" (например, временное повышение приоритета ожидающих процессов).
- Гарантированное планирование, где каждый процесс получает минимальную долю ресурсов.