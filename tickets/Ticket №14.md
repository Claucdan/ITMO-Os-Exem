# Виды планирования и их место в жизненном цикле процесса.
### **Виды планирования и их место в жизненном цикле процесса**  

Планирование процессов — это ключевая функция операционной системы, которая определяет порядок выполнения задач для эффективного использования ресурсов. В зависимости от этапа жизненного цикла процесса применяются разные алгоритмы планирования.  

---

## **1. Жизненный цикл процесса и планирование**  
Процесс проходит несколько этапов:  
- **Создание** → **Готовность** → **Выполнение** → **Ожидание (I/O)** → **Завершение**.  

На каждом этапе могут применяться разные алгоритмы планирования:  
- **Долгосрочное планирование** (выбор процессов для загрузки в память).  
- **Среднесрочное планирование** (свопинг, управление нагрузкой).  
- **Краткосрочное планирование** (выбор следующего процесса для выполнения на CPU).  

Мы рассматриваем **краткосрочное планирование**, которое работает на этапах **Готовность ↔ Выполнение**.  

---

## **2. Виды алгоритмов планирования**  

### **(1) Невытесняющие (Non-preemptive)**  
Процесс удерживает CPU, пока не завершится или не перейдет в ожидание.  
**Примеры:**  
- **FCFS (First-Come, First-Served)**  
  - Процессы выполняются в порядке поступления.  
  - **Плюсы:** Простота.  
  - **Минусы:** Долгое ожидание "длинных" процессов ("голодание" коротких).  
  - **Применение:** Устаревшие системы, пакетная обработка.  

- **SJF (Shortest Job First)**  
  - Выбирается процесс с наименьшим **CPU burst**.  
  - **Плюсы:** Минимизирует среднее время выполнения.  
  - **Минусы:** Несправедливость, требует знания длительности процессов.  
  - **Применение:** Специализированные системы с предсказуемой нагрузкой.  

---

### **(2) Вытесняющие (Preemptive)**  
Планировщик может прервать выполнение процесса.  
**Примеры:**  
- **Round Robin (RR)**  
  - Каждый процесс получает **фиксированный квант времени (time slice)**.  
  - **Плюсы:** Справедливость, хорошая реакция на интерактивные задачи.  
  - **Минусы:** Зависимость от выбора кванта (слишком малый → накладные расходы, слишком большой → как FCFS).  
  - **Применение:** Интерактивные системы (гипервизоры, ОС общего назначения).  

- **Многоуровневые очереди (Multilevel Queue)**  
  - Процессы распределяются по приоритетным очередям (например: системные > интерактивные > фоновые).  
  - **Плюсы:** Гибкость, учет приоритетов.  
  - **Минусы:** Возможность "голодания" низкоприоритетных процессов.  
  - **Применение:** Серверные ОС, реального времени.  

- **Многоуровневые очереди с обратной связью (Multilevel Feedback Queue, MLFQ)**  
  - Процессы могут **перемещаться между очередями** в зависимости от поведения.  
    - Если процесс часто освобождает CPU (интерактивный), он повышается в приоритете.  
    - Если использует весь квант, понижается.  
  - **Плюсы:** Баланс между отзывчивостью и справедливостью.  
  - **Минусы:** Сложность настройки.  
  - **Применение:** Современные ОС (Linux, Windows).  

---

## **3. Оптимальный выбор алгоритма**  
Зависит от типа задач:  
- **Интерактивные системы (UI, сервисы)** → **RR, MLFQ** (быстрый отклик).  
- **Вычислительные задачи (серверы, HPC)** → **SJF, FCFS** (минимизация времени выполнения).  
- **Гибридные системы** → **Многоуровневые очереди**.  

### **Критерии эффективности планировщика:**  
- **Предсказуемость** (стабильность времени отклика).  
- **Масштабируемость** (работа при большом числе процессов).  
- **Оптимальность** (минимум накладных расходов).  