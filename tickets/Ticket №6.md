# Виды архитектур ядер операционных систем. Общая характеристика каждого вида, достоинства и недостатки.
## Монолитная архитектура
#### Общая информация
1. **Главная программа** принимает системные вызовы. Главная программа знает, какой процесс его вызвал, что за системный вызов и аргументы вызова, а после передает вызов в нужный сервис
2. **Сервисы** выполняют определенный вызов, используя утилиты. Если сервис не может совершить операцию (например, мало оперативной памяти), то вызов передается обратно в главную программу
3. **Утилиты** - часть ядра, задействующая аппаратное обеспечение (по факту драйвера)
![[Pasted image 20250622085816.png]]
#### Достоинства
- **Высокая производительность** – минимум переключений между режимами.  
- **Простота разработки** – все компоненты тесно интегрированы.
- **Эффективное использование ресурсов** – отсутствие накладных расходов на IPC.
#### Недостатки
- **Низкая отказоустойчивость** – ошибка в драйвере может привести к краху всей системы.  
- **Cложность масштабирования** – добавление новых функций требует перекомпиляции ядра.  
- **Большой объем кода в памяти** – занимает много ОЗУ.

## Многослойная монолитная архитектура
#### Общая информация
В многослойной монолитной архитектуре слоев стало больше:
1. **Аппаратное обеспечение**
2. **Аппаратная поддержка ядра** определяется чипсетом и кодом в микроконтроллерах на материнской плате
3. **Машинно-зависимые модули** (HAL - Hardware Abstraction Layer, драйвера или модули ядра) абстрагируют код ядра от аппаратного обеспечения
4. **Базовые механизмы ядра** - базовые детерминированные алгоритмы
5. **Менеджер ресурсов** - стохастические алгоритмы, принимающие решения по организации ресурсов
6. **Системные вызовы и API**
Круги отражают размер кода соответствующего уровня, например, аппаратная поддержка ядра - микрокод на чипсете, занимающий порядка килобайта, тогда как менеджер ресурсов может занимать уже мегабайты.
![[Pasted image 20250622085759.png]]
Ядро становилось все больше и больше, а оперативная память не увеличивалась такими большими темпами - поэтому ядро стало занимать все большую часть памяти
Второй проблемой стала задача построения распределенных систем. Если разместить на двух узлах операционные системы, то они должны разделять пул ресурсов, а также иметь одного менеджера для согласованности решений. Поэтому было принято решение вынести менеджеров ресурсов за пределы ядра.
#### Достоинства
- **Лучшая структурированность** – проще поддерживать и развивать.  
- **Абстракция от железа** – HAL скрывает различия между платформами.
#### Недостатки
- **По-прежнему монолит** – те же проблемы с надежностью и масштабируемостью.
## ### Микроядерная архитектура
#### Общая информация
В микроядерной архитектура можно выделить условно три слоя: АО, ПО в режиме ядра (привилегированном), ПО в пользовательском режиме. Базовые механизмы ядра, обработчики системых вызовов и HAL остаются в пределах ядра, а другие сервисы (такие как сервера памяти, дисков, библиотеки, API и т. д.) существуют как процессы внутри пользовательского режима

Пример: приложение хочет выделить память на куче, приложение вызывает вызов API, который переводит его библиотеке, которая переводит его серверу памяти и т. д. - между всеми этими переводами стоит ядро
![[Pasted image 20250622091154.png]]
В микроядерной архитектуре модули на уровне пользовательского режима можно вынести в подкачку на диск. Но вместо этого мы получили десятки переключений процессов и использование виртуализации
![[Pasted image 20250622091212.png]]

Также возникают проблемы с надежностью, например, выгрузка сервера диска в файл подкачки на диск. В это время ядро с монолитной архитектурой весит намного больше ядра микроядерного

Надо понимать, что нет лучшего решения между монолитной и микроядерной архитектурами - все это поиск компромисса
#### Достоинства
- **Высокая надежность** – падение сервера не затрагивает ядро.  
- **Гибкость** – компоненты можно заменять без перезагрузки.  
- **Безопасность** – изоляция сервисов снижает риск эксплойтов.
#### Недостатки
- **Низкая производительность** – частые переключения контекста и IPC. 
- **Сложность разработки** – требуется тщательное проектирование взаимодействий.
## Другие Архитектуры
### Модульная архитектура
#### Общая информация
В Linux пришли к модульной архитектуре: компоненты ядра независимы и соединены между собой очередями запросов. Во время переключения компонентов запросы скапливаются в очередь, а при подключении новый компонент отрабатывает эти запросы. Таким образом, модули можно менять прямо в рантайме
![[Pasted image 20250622091241.png]]
#### Достоинства
- **Гибкость** – модули можно загружать и выгружать на лету.  
- **Производительность** – критичные компоненты работают в ядре.
#### Недостатки
- **Риск нестабильности** – ошибка в модуле может повлиять на ядро.
### Наноядерная архитектура
#### Общая информация
В наноядерной архитектуре ядро разделяют “поперек” слоев. В них может быть, например, упрощенный менеджер ресурсов или набор только необходимых драйверов
Наноядерная архитектура применяется в системах виртуализации
### Экзоядерная архитектура
#### Общая информация
В экзоядерной архитектуре машинно-зависимые модули выносят наружу ядра (а именно в библиотеки с пользовательским режимом), а менеджер ресурсов внутри, чтобы он работал без виртуализации
### Гибридная архитектура
#### Общая информация
В гибридной архитектуре предполагается, что модули ядра можно оставлять в ядре, можно делать вокруг них обертку для их виртуализации и вынести в пользовательский режим