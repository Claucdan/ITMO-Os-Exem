# Принципы работы планировщиков O(1) и CFS в операционных системах GNU/Linux.
## O(1)
Планировщик O(1) в Linux, появившийся в ядре 2.6, был разработан для эффективного управления процессами с постоянным временем выполнения операций, независимо от количества процессов в системе. Вот его основные принципы работы:
### Многоуровневые очереди
- Планировщик использует **140 пар очередей** (по 2 очереди на каждый приоритет: активную и неактивную).
- Приоритеты делятся на два класса:
    - **Процессы реального времени** (приоритеты 1–100, где 1 — наивысший).
    - **Пользовательские процессы** (приоритеты 101–140, где 101 — наивысший, 140 — низший).
- Каждая очередь соответствует одному приоритету и работает по принципу **FIFO** (для процессов реального времени) или **Round Robin** (для пользовательских процессов).
### Активные и неактивные очереди
- **Активная очередь** содержит процессы, готовые к выполнению.
- **Неактивная очередь** хранит процессы, которые уже использовали свой квант времени и ожидают следующего выполнения.
- Когда все процессы из активной очереди исчерпают свои кванты, происходит **переключение**:
  - Активная очередь становится неактивной.
  - Неактивная очередь становится активной.
### Кванты времени
- Каждому процессу выделяется **квант времени**, зависящий от его приоритета:
  - Высокоприоритетные процессы (например, приоритет 101) получают больший квант (например, 200 мс).
  - Низкоприоритетные процессы (например, приоритет 140) получают меньший квант (например, 10 мс).
- Если процесс **добровольно уходит в ожидание** (например, для ввода-вывода), он возвращается в ту же очередь с оставшимся квантом.
- Если процесс **использует весь квант**, он перемещается в неактивную очередь.
### Борьба с голоданием
- Если процесс долго не получает CPU (например, находится в низкоприоритетной очереди), его приоритет **постепенно повышается**.
- Это гарантирует, что даже низкоприоритетные процессы рано или поздно получат время для выполнения.
### Быстрый выбор процесса
- Для быстрого поиска очереди с процессами используется **битовый вектор**, где каждый бит соответствует наличию процессов в очереди с данным приоритетом.
- Это позволяет находить следующий процесс для выполнения за **константное время O(1)**.
### Поддержка многопроцессорности
- Каждое ядро CPU имеет **собственный набор очередей**, что уменьшает конкуренцию за ресурсы.
- Периодически (примерно каждые 200 мс) происходит **балансировка нагрузки** между ядрами.
### Управление приоритетами
- Пользователь может влиять на приоритет процесса через параметр **nice**:
  - `nice = -20` соответствует приоритету 101 (наивысший для пользовательских процессов).
  - `nice = +19` соответствует приоритету 140 (низший).
## CFS
### Ключевая идея  
   CFS стремится обеспечить каждому процессу долю процессорного времени, пропорциональную его приоритету. Для этого он использует виртуальное время (`vruntime`), которое учитывает время, уже использованное процессом, и его приоритет (значение `nice`).
### Виртуальное время (vruntime)  
- Каждый процесс имеет свое виртуальное время, которое увеличивается пропорционально реальному времени выполнения.  
- Чем выше приоритет процесса (меньше значение `nice`), тем медленнее увеличивается его `vruntime`.  
- CFS всегда выбирает для выполнения процесс с наименьшим `vruntime`, чтобы компенсировать отставание.
### Красно-черное дерево  
- Процессы организованы в красно-черное дерево, отсортированное по `vruntime`.  
- Легковесные процессы (с наименьшим `vruntime`) находятся в левой части дерева, что позволяет быстро находить следующий процесс для выполнения.  
- Вставка и удаление процессов из дерева выполняются за время \(O(\log n)\).
### Гранулированность  
- CFS использует минимальный квант времени (гранулу), чтобы избежать слишком частых переключений между процессами.  
- Это балансирует между справедливостью и накладными расходами на переключение контекста.
### Приоритеты (nice  
- Значение `nice` (от -20 до +19) влияет на вес процесса. Чем меньше `nice`, тем больше вес и тем больше процессорного времени получает процесс.  
- Вес используется для коррекции скорости увеличения `vruntime`.
### Групповая планировка  
- CFS поддерживает контрольные группы (cgroups), позволяя распределять ресурсы между группами процессов (например, пользователями или приложениями).
### Пример работы  
   - Если процесс A (`nice=0`) и процесс B (`nice=5`) конкурируют за процессор, CFS выделит больше времени процессу A, так как его `vruntime` будет увеличиваться медленнее.