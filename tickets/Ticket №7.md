# Монолитная архитектура операционной системы. Подробное описание компонентов (слоев), их назначение и взаимодействие между собой. Достоинства и недостатки монолитной архитектуры ядра.
## Монолитная архитектура операционной системы
Монолитная архитектура — классический подход к построению ядра ОС, при котором **все компоненты работают в едином адресном пространстве** и имеют прямой доступ друг к другу. Это обеспечивает высокую производительность, но снижает отказоустойчивость.  
## Компоненты (слои) монолитного ядра
В монолитной архитектуре выделяют **три основных слоя**, взаимодействующих друг с другом:  
### Главная программа 
- Обрабатывает **системные вызовы** (API) от пользовательских приложений.  
- Определяет, какой сервис должен выполнить запрос.  
- Управляет передачей управления между слоями.  
### Сервисы (функциональные модули)
- Реализуют логику работы ОС:  
  - Управление процессами (`fork()`, `exec()`).  
  - Работа с памятью (`malloc()`, `mmap()`).  
  - Файловые операции (`open()`, `write()`).  
- Если сервис не может выполнить операцию (например, нет свободной памяти), возвращает ошибку в главную программу.  
### Утилиты (драйверы и низкоуровневые функции)
- Непосредственное взаимодействие с **аппаратурой**:  
  - Драйверы устройств (диски, сетевые карты).  
  - Управление прерываниями (IRQ).  
  - Работа с регистрами CPU.  
## Взаимодействие между слоями

1. **Пользовательское приложение** делает системный вызов (например, `read()`).  
2. **Главная программа** ядра:  
   - Проверяет права процесса.  
   - Определяет, какой сервис должен обработать запрос (в данном случае — файловая система).  
3. **Сервис файловой системы**:  
   - Ищет файл в кэше или на диске.  
   - Формирует запрос к драйверу диска.  
4. **Драйвер диска**:  
   - Отправляет команды контроллеру диска.  
   - Читает данные в буфер ядра.  
5. Данные возвращаются по цепочке обратно в приложение.  

**Схема:**  
```
Приложение → Системный вызов → Ядро → Сервис → Драйвер → Аппаратура
```
## Достоинства монолитной архитектуры  
#### Высокая производительность 
- Нет накладных расходов на IPC (в отличие от микроядер).  
- Минимальные задержки при обработке системных вызовов.  
#### Простота разработки  
- Все компоненты тесно интегрированы, можно использовать общие структуры данных.  
#### Эффективное использование ресурсов  
- Нет дублирования кода (например, буферизация в файловой системе и драйверах).  
## Недостатки монолитной архитектуры 
#### Низкая отказоустойчивость
- Ошибка в драйвере или сервисе может **положить всю систему** (kernel panic).
#### Сложность масштабирования
- Добавление новых функций требует **перекомпиляции ядра**.  
- Большой объем кода усложняет отладку.  
#### Проблемы с безопасностью
- Любой компонент имеет доступ ко всем данным ядра (нет изоляции).