# Алгоритмы реализации взаимоисключений. Формальное описание алгоритмов, их недостатки.
## Алгоритмы реализации взаимоисключений
Взаимоисключение (mutual exclusion) — это механизм, который гарантирует, что только один процесс может находиться в критической секции кода в любой момент времени. Это необходимо для предотвращения конфликтов при доступе к общим ресурсам. Рассмотрим несколько алгоритмов реализации взаимоисключений, их формальное описание и недостатки.
### Lock
#### Формальное описание
```c
shared int lock = 0;

P_i() {
    while (lock) {};  // Пролог: ожидание освобождения замка
    lock = 1;         // Захват замка

    // Критическая секция

    lock = 0;         // Эпилог: освобождение замка
}
```
#### Недостатки
- Нарушение условия взаимоисключения: если процесс прервется после проверки `while (lock) {}`, но до установки `lock = 1`, другой процесс может войти в критическую секцию.
- Активное ожидание (busy waiting), что приводит к неэффективному использованию процессора.
### Strict Alternation
#### Формальное описание
```c
shared int turn = 0;

P_i() {
    while (turn != i) {};  // Пролог: ожидание своей очереди

    // Критическая секция

    turn = 1 - i;          // Эпилог: передача хода другому процессу
}
```
#### Недостатки
- Нарушение условия прогресса: если процесс `P_1` не хочет входить в критическую секцию, процесс `P_0` не сможет войти в нее повторно, даже если ресурс свободен.
- Подходит только для двух процессов.
### Flags
#### Формальное описание
```c
shared int ready[2] = {0, 0};

P_i() {
    ready[i] = 1;              // Пролог: объявление о намерении войти
    while (ready[1 - i]) {};   // Ожидание, пока другой процесс не выйдет

    // Критическая секция

    ready[i] = 0;              // Эпилог: освобождение ресурса
}
```
#### Недостатки
- Возможность взаимной блокировки (deadlock): если оба процесса почти одновременно установят `ready[i] = 1`, они оба будут ждать друг друга.
- Нарушение условия прогресса.
### Peterson's Algorithm
#### Формальное описание
```c
shared int ready[2] = {0, 0};
shared int turn = 0;

P_i() {
    ready[i] = 1;                     // Пролог: объявление о намерении войти
    turn = 1 - i;                     // Уступка хода другому процессу
    while (ready[1 - i] && turn == 1 - i) {};  // Ожидание

    // Критическая секция

    ready[i] = 0;                     // Эпилог: освобождение ресурса
}
```
#### Недостатки
- Подходит только для двух процессов.
- Сложность масштабирования на большее количество процессов из-за увеличения накладных расходов.
### Test-and-Set
#### Формальное описание
```c
shared int lock = 0;

P_i() {
    while (test_and_set(&lock)) {};  // Пролог: атомарная проверка и установка замка

    // Критическая секция

    lock = 0;                        // Эпилог: освобождение замка
}
```
#### Недостатки
- Активное ожидание, что неэффективно для длительных критических секций.
- Требует поддержки со стороны аппаратуры (специальной инструкции `test_and_set`).
### Semaphores
#### Формальное описание
```c
Semaphore S = 1;

P_i() {
    P(S);  // Пролог: уменьшение семафора (захват ресурса)

    // Критическая секция

    V(S);  // Эпилог: увеличение семафора (освобождение ресурса)
}
```
#### Недостатки
- Возможность взаимных блокировок (deadlocks) при неправильном использовании.
- Требует аккуратного управления, особенно в сложных системах с множеством ресурсов.